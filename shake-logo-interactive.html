<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shake On - Interactive Logo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #011E42;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        .container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100vh;
        }

        /* Logo container with splatter area */
        .logo-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            z-index: 10;
            padding: 200px; /* Extra space for splatters to be visible */
        }

        /* Splatter canvas overlay */
        .splatter-canvas {
            position: absolute;
            top: -200px;
            left: -200px;
            width: calc(100% + 400px);
            height: calc(100% + 400px);
            pointer-events: none;
            z-index: 1;
            /* Transparent - paint splatters will show on white body background */
        }

        /* Logo layers container */
        .logo-layers {
            position: relative;
            display: inline-block;
        }

        .logo-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .logo-layer.active {
            opacity: 1;
        }

        .logo-base {
            position: relative;
            width: 600px;
            height: auto;
            display: block;
            z-index: 2;
            filter: drop-shadow(0 4px 20px rgba(0, 0, 0, 0.1));
            transition: filter 0.3s ease;
        }

        .color-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            opacity: 0;
            transition: opacity 0.4s ease;
            mix-blend-mode: multiply;
        }

        .color-overlay.active {
            opacity: 1;
        }

        /* Wet dog shake animation */
        @keyframes wet-dog-shake {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            2% { transform: translate(-15px, -8px) rotate(-8deg); }
            4% { transform: translate(18px, 12px) rotate(10deg); }
            6% { transform: translate(-20px, -10px) rotate(-12deg); }
            8% { transform: translate(22px, 14px) rotate(14deg); }
            10% { transform: translate(-18px, -12px) rotate(-10deg); }
            12% { transform: translate(20px, 10px) rotate(12deg); }
            14% { transform: translate(-16px, -14px) rotate(-14deg); }
            16% { transform: translate(19px, 11px) rotate(11deg); }
            18% { transform: translate(-17px, -9px) rotate(-9deg); }
            20% { transform: translate(15px, 13px) rotate(9deg); }
            22% { transform: translate(-12px, -8px) rotate(-7deg); }
            24% { transform: translate(10px, 6px) rotate(5deg); }
            26% { transform: translate(-8px, -4px) rotate(-3deg); }
            28% { transform: translate(6px, 3px) rotate(2deg); }
            30% { transform: translate(-4px, -2px) rotate(-1deg); }
            32% { transform: translate(2px, 1px) rotate(0.5deg); }
            34%, 100% { transform: translate(0, 0) rotate(0deg); }
        }

        .logo-base.shaking {
            animation: wet-dog-shake 2s ease-out;
        }

        /* Splatter particles */
        .splatter-particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
        }

        @keyframes splatter-fly {
            0% {
                opacity: 1;
                transform: scale(0) translate(0, 0);
            }
            10% {
                opacity: 0.9;
            }
            100% {
                opacity: 0;
                transform: scale(1.5) translate(var(--tx), var(--ty));
            }
        }

        .splatter-particle {
            animation: splatter-fly 1.5s ease-out forwards;
        }

        /* Color reveal stages */
        .color-stage {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.4s ease;
            pointer-events: none;
        }

        .color-stage.revealed {
            opacity: 1;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .logo-base {
                width: 400px;
            }
        }

        @media (max-width: 480px) {
            .logo-base {
                width: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo-wrapper" id="logoWrapper">
            <canvas class="splatter-canvas" id="splatterCanvas"></canvas>
            <div class="logo-layers">
                <div class="color-overlay" id="colorOverlay"></div>
                <img src="SO-BLK_1@3x-8.png" alt="Shake On Logo" class="logo-base" id="logoBase">
            </div>
        </div>
    </div>

    <script>
        // Color palette in reveal order (matching ShakeOn brand colors)
        const colors = [
            { name: 'black', hex: '#000000' },
            { name: 'grey', hex: '#71777B' },
            { name: 'turquoise', hex: '#01B9B3' },
            { name: 'white', hex: '#FFFFFF' },
            { name: 'orange', hex: '#FF5F1F' },
            { name: 'navy', hex: '#011E42' }
        ];

        const logoWrapper = document.getElementById('logoWrapper');
        const logoBase = document.getElementById('logoBase');
        const splatterCanvas = document.getElementById('splatterCanvas');
        const ctx = splatterCanvas.getContext('2d');

        let currentColorIndex = 0;
        let isShaking = false;
        let animationId = null;

        // Set canvas size with extra padding for splatters
        function resizeCanvas() {
            const logoRect = logoBase.getBoundingClientRect();
            const padding = 400; // Extra space for splatters
            const canvasSize = Math.max(logoRect.width, logoRect.height) + padding;
            
            // Handle high DPI displays
            const dpr = window.devicePixelRatio || 1;
            splatterCanvas.width = canvasSize * dpr;
            splatterCanvas.height = canvasSize * dpr;
            splatterCanvas.style.width = canvasSize + 'px';
            splatterCanvas.style.height = canvasSize + 'px';
            
            // Reset transform and scale context for high DPI
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Create splatter particles with varied patterns based on color stage
        function createSplatterParticle(x, y, color, colorIndex, stage) {
            // Different patterns for each color stage
            let angle, speed, size, spread;
            
            if (colorIndex === 1) { // Grey - sparse, subtle
                angle = Math.random() * Math.PI * 2;
                speed = Math.random() * 15 + 8;
                size = Math.random() * 8 + 4;
                spread = 0.6; // Tighter spread
            } else if (colorIndex === 2) { // Turquoise - moderate, directional
                angle = (Math.random() - 0.5) * Math.PI * 1.5 + Math.PI / 2; // More downward
                speed = Math.random() * 18 + 10;
                size = Math.random() * 12 + 6;
                spread = 0.8;
            } else if (colorIndex === 3) { // White - scattered, varied sizes
                angle = Math.random() * Math.PI * 2;
                speed = Math.random() * 22 + 12;
                size = Math.random() * 20 + 5; // More size variation
                spread = 1.0;
            } else if (colorIndex === 4) { // Orange - dense, energetic
                angle = Math.random() * Math.PI * 2;
                speed = Math.random() * 25 + 15;
                size = Math.random() * 18 + 8;
                spread = 1.2; // Wider spread
            } else { // Navy - very dense, chaotic
                angle = Math.random() * Math.PI * 2;
                speed = Math.random() * 30 + 18;
                size = Math.random() * 25 + 10; // Largest sizes
                spread = 1.5; // Widest spread
            }
            
            // Add randomness to angle
            angle += (Math.random() - 0.5) * 0.5;
            
            return {
                x: x + (Math.random() - 0.5) * spread * 20,
                y: y + (Math.random() - 0.5) * spread * 20,
                color: color,
                size: size,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1.0,
                decay: Math.random() * 0.04 + 0.02,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.8,
                shape: Math.random(),
                painted: false,
                colorIndex: colorIndex,
                splatterType: Math.random() // For different splatter styles
            };
        }

        const particles = [];

        const colorOverlay = document.getElementById('colorOverlay');

        // Color filter mappings for accurate colorization
        const colorFilters = {
            0: { src: 'SO-BLK_1@3x-8.png', filter: 'drop-shadow(0 4px 20px rgba(0, 0, 0, 0.1))' }, // Black
            1: { src: 'SO-WHT_1@3x-8.png', filter: 'drop-shadow(0 4px 20px rgba(0, 0, 0, 0.1)) brightness(0) saturate(100%) invert(55%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(90%)' }, // Grey #71777B
            2: { src: 'SO-WHT_1@3x-8.png', filter: 'drop-shadow(0 4px 20px rgba(0, 0, 0, 0.1)) brightness(0) saturate(100%) invert(70%) sepia(100%) saturate(2000%) hue-rotate(160deg) brightness(95%)' }, // Turquoise #01B9B3
            3: { src: 'SO-WHT_1@3x-8.png', filter: 'drop-shadow(0 4px 20px rgba(0, 0, 0, 0.1))' }, // White
            4: { src: 'SO-WHT_1@3x-8.png', filter: 'drop-shadow(0 4px 20px rgba(0, 0, 0, 0.1)) brightness(0) saturate(100%) invert(50%) sepia(100%) saturate(5000%) hue-rotate(0deg) brightness(110%)' }, // Orange #FF5F1F
            5: { src: 'SO-WHT_1@3x-8.png', filter: 'drop-shadow(0 4px 20px rgba(0, 0, 0, 0.1)) brightness(0) saturate(100%) invert(8%) sepia(100%) saturate(5000%) hue-rotate(200deg) brightness(30%)' } // Navy #011E42
        };

        // Apply logo color
        function applyLogoColor(colorIndex) {
            const filterConfig = colorFilters[colorIndex];
            logoBase.src = filterConfig.src;
            logoBase.style.filter = filterConfig.filter;
            
            // Hide overlay for all cases (using filters instead)
            colorOverlay.classList.remove('active');
        }

        // Create paint splatter effect
        function createPaintSplatter() {
            if (isShaking) return;
            
            isShaking = true;
            currentColorIndex = 0;
            applyLogoColor(0);
            logoBase.classList.add('shaking');
            
            // Clear canvas at start of new animation
            const dpr = window.devicePixelRatio || 1;
            ctx.clearRect(0, 0, splatterCanvas.width / dpr, splatterCanvas.height / dpr);
            particles.length = 0;
            
            // Get logo position relative to canvas
            // Canvas is positioned at -200px, -200px relative to wrapper
            // Logo is centered in wrapper with 200px padding
            const logoRect = logoBase.getBoundingClientRect();
            const wrapperRect = logoWrapper.getBoundingClientRect();
            // Calculate center relative to canvas (which starts at -200px, -200px)
            const logoCenterX = (logoRect.left - wrapperRect.left) + 200 + logoRect.width / 2;
            const logoCenterY = (logoRect.top - wrapperRect.top) + 200 + logoRect.height / 2;
            const logoWidth = logoRect.width;
            const logoHeight = logoRect.height;

            // Create color reveal sequence with increasing intensity and bursts
            const colorSequence = [
                { index: 1, count: 25, delay: 0, bursts: 1 },      // Grey - sparse
                { index: 2, count: 50, delay: 400, bursts: 2 },   // Turquoise - moderate, 2 bursts
                { index: 3, count: 80, delay: 900, bursts: 2 },   // White - more, 2 bursts
                { index: 4, count: 120, delay: 1400, bursts: 3 }, // Orange - dense, 3 bursts
                { index: 5, count: 200, delay: 2000, bursts: 4 }   // Navy - very dense, 4 bursts
            ];

            colorSequence.forEach((stage) => {
                // Create multiple bursts for each color stage
                for (let burst = 0; burst < stage.bursts; burst++) {
                    setTimeout(() => {
                        const color = colors[stage.index];
                        if (burst === 0) {
                            currentColorIndex = stage.index;
                            applyLogoColor(stage.index);
                        }
                        
                        // Particles per burst
                        const particlesPerBurst = Math.floor(stage.count / stage.bursts);
                        
                        // Create splatter particles with increasing density
                        for (let i = 0; i < particlesPerBurst; i++) {
                            // Vary starting positions - more spread for later stages
                            const spreadFactor = 0.6 + (stage.index - 1) * 0.2;
                            const startX = logoCenterX + (Math.random() - 0.5) * logoWidth * spreadFactor;
                            const startY = logoCenterY + (Math.random() - 0.5) * logoHeight * spreadFactor;
                            
                            particles.push(createSplatterParticle(startX, startY, color, stage.index, stage));
                        }
                    }, stage.delay + (burst * 150)); // Stagger bursts
                }
            });

            // Reset after animation completes (keep splatters visible)
            const finalDelay = colorSequence[colorSequence.length - 1].delay + 
                              (colorSequence[colorSequence.length - 1].bursts * 150) + 2000;
            setTimeout(() => {
                logoBase.classList.remove('shaking');
                isShaking = false;
                // Splatters stay visible - they accumulate beautifully!
            }, finalDelay);
        }

        // Paint a splatter mark onto the canvas (permanent) with varied styles
        function paintSplatterMark(x, y, size, color, rotation, shape, colorIndex, splatterType) {
            ctx.save();
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = color.hex;
            ctx.translate(x, y);
            ctx.rotate(rotation);
            
            // Different splatter styles based on type and color
            const style = splatterType;
            let dropletCount, dropletSpread;
            
            if (colorIndex === 1) { // Grey - minimal droplets
                dropletCount = 1 + Math.floor(Math.random() * 2);
                dropletSpread = 0.3;
            } else if (colorIndex === 2) { // Turquoise - moderate
                dropletCount = 2 + Math.floor(Math.random() * 3);
                dropletSpread = 0.5;
            } else if (colorIndex === 3) { // White - varied
                dropletCount = 3 + Math.floor(Math.random() * 4);
                dropletSpread = 0.7;
            } else if (colorIndex === 4) { // Orange - dense
                dropletCount = 4 + Math.floor(Math.random() * 5);
                dropletSpread = 0.9;
            } else { // Navy - very dense
                dropletCount = 5 + Math.floor(Math.random() * 7);
                dropletSpread = 1.2;
            }
            
            // Draw main splatter shape with more variation - more organic for later stages
            ctx.beginPath();
            if (colorIndex <= 2 && style < 0.3) {
                // Early stages - simpler shapes
                ctx.ellipse(0, 0, size, size * 0.5, rotation, 0, Math.PI * 2);
            } else if (style < 0.15) {
                // Long elliptical splatter
                ctx.ellipse(0, 0, size, size * 0.35, rotation, 0, Math.PI * 2);
            } else if (style < 0.3) {
                // Wide elliptical
                ctx.ellipse(0, 0, size * 0.65, size, rotation, 0, Math.PI * 2);
            } else if (style < 0.45) {
                // Teardrop
                ctx.arc(0, 0, size * 0.75, 0, Math.PI * 2);
                ctx.lineTo(size * 0.5, size * 1.3);
            } else if (style < 0.6) {
                // Star-like splatter (more points for later stages)
                const points = colorIndex >= 4 ? 6 : 5;
                for (let i = 0; i < points; i++) {
                    const angle = (i / points) * Math.PI * 2 + rotation;
                    const px = Math.cos(angle) * size;
                    const py = Math.sin(angle) * size;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
            } else if (style < 0.75) {
                // Irregular blob with multiple lobes
                ctx.arc(0, 0, size * 0.85, 0, Math.PI * 2);
                // Add extra lobes (more for later stages)
                const lobeCount = colorIndex >= 4 ? 4 : 3;
                for (let i = 0; i < lobeCount; i++) {
                    const lobeAngle = (i / lobeCount) * Math.PI * 2 + rotation;
                    const lobeX = Math.cos(lobeAngle) * size * 0.55;
                    const lobeY = Math.sin(lobeAngle) * size * 0.55;
                    ctx.arc(lobeX, lobeY, size * 0.35, 0, Math.PI * 2);
                }
            } else if (style < 0.9) {
                // Organic irregular shape
                const points = 8;
                for (let i = 0; i < points; i++) {
                    const angle = (i / points) * Math.PI * 2 + rotation;
                    const radius = size * (0.7 + Math.random() * 0.3);
                    const px = Math.cos(angle) * radius;
                    const py = Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
            } else {
                // Simple circle (less common in later stages)
                ctx.arc(0, 0, size, 0, Math.PI * 2);
            }
            ctx.fill();
            
            // Add smaller splatter droplets around main particle
            for (let j = 0; j < dropletCount; j++) {
                const offsetAngle = Math.random() * Math.PI * 2;
                const offsetDist = size * (0.3 + Math.random() * dropletSpread);
                const offsetX = Math.cos(offsetAngle) * offsetDist;
                const offsetY = Math.sin(offsetAngle) * offsetDist;
                const dropletSize = size * (0.1 + Math.random() * 0.4);
                
                ctx.beginPath();
                ctx.arc(offsetX, offsetY, dropletSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Add even smaller micro-droplets for later stages
                if (colorIndex >= 3 && Math.random() > 0.7) {
                    const microAngle = Math.random() * Math.PI * 2;
                    const microDist = dropletSize * 1.5;
                    const microX = offsetX + Math.cos(microAngle) * microDist;
                    const microY = offsetY + Math.sin(microAngle) * microDist;
                    ctx.beginPath();
                    ctx.arc(microX, microY, dropletSize * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }

        // Animate particles - they paint and stick, don't fall
        function animateParticles() {
            const dpr = window.devicePixelRatio || 1;
            // Don't clear the canvas - let paint marks accumulate!

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                
                // Update position (no gravity - splatters fly outward)
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.88; // Friction slows them down
                p.vy *= 0.88;
                p.rotation += p.rotationSpeed;
                
                // Paint the particle onto canvas when it slows down enough or life is low
                if (!p.painted && (p.life < 0.4 || Math.abs(p.vx) < 1 && Math.abs(p.vy) < 1)) {
                    paintSplatterMark(p.x, p.y, p.size, p.color, p.rotation, p.shape, p.colorIndex, p.splatterType);
                    p.painted = true;
                }
                
                // Update life
                p.life -= p.decay;
                
                // Draw moving particle (fading trail)
                if (!p.painted && p.life > 0) {
                    ctx.save();
                    ctx.globalAlpha = Math.min(p.life, 0.8);
                    ctx.fillStyle = p.color.hex;
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    
                    const size = p.size;
                    ctx.beginPath();
                    if (p.shape < 0.3) {
                        ctx.ellipse(0, 0, size, size * 0.6, p.rotation, 0, Math.PI * 2);
                    } else if (p.shape < 0.6) {
                        ctx.arc(0, 0, size * 0.8, 0, Math.PI * 2);
                    } else {
                        ctx.arc(0, 0, size * 0.9, 0, Math.PI * 2);
                    }
                    ctx.fill();
                    ctx.restore();
                }
                
                // Remove particle after it's painted and faded
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            if (particles.length > 0 || isShaking) {
                animationId = requestAnimationFrame(animateParticles);
            }
        }

        // Initialize with black logo
        applyLogoColor(0);
        
        // Start animation loop
        animateParticles();

        // Auto-start animation after page loads
        window.addEventListener('load', () => {
            // Wait a moment for everything to render, then start animation
            setTimeout(() => {
                createPaintSplatter();
                if (!animationId) {
                    animateParticles();
                }
            }, 500);
        });

        // Also start immediately if already loaded
        if (document.readyState === 'complete') {
            setTimeout(() => {
                createPaintSplatter();
                if (!animationId) {
                    animateParticles();
                }
            }, 500);
        }
    </script>
</body>
</html>

